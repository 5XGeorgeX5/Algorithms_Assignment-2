struct Hash {
    const size_t size = 1009, r = 4;
    const double A = 0.618033;
    vector<long long> numbers;
    int method;

    Hash(int method) {
        numbers.resize(size, -1);
        this->method = method;
    }

    bool add(long long number) {
        auto add = [&](int index, long long number) {
            if (numbers[index] == -1) {
                numbers[index] = number;
                return true;
            }
            return false;
        };
        if (method == 0) {
            return add(number % size, number);
        }
        if (method == 1) {
            int index = (int) floor(size * fmod(A * number, 1));
            return add(index, number);
        }
        if (method == 2) {
            // assume no overflow
            ll squared_number = number * number;
            auto getIndex = [&]() {
                string s = to_string(squared_number);
                int num_of_digits = (int) s.size();
                if (num_of_digits <= 4) return squared_number;
                return stoll(s.substr((num_of_digits - 4) / 2, 4));
            };
            return add(getIndex(), number);
        }
        if (method == 3) {
            ll squared_number = number * number;
            auto getIndex = [&]() {
                string s = to_string(squared_number);
                int index{};
                for (size_t i{}; i < s.size(); i += r) {
                    if (i + r <= s.size()) {
                        index += stoi(s.substr(i, r));
                    } else {
                        index += stoi(s.substr(i));
                    }
                }
                return index % size;
            };
            return add(getIndex(), number);
        }
        return false;
    }

};

struct chainingMethod {
    vector<multiset<long long>> numbers;
    const int SIZE = 1009;

    void add(long long number) {
        numbers[number % SIZE].emplace(number);
    }

    bool find(long long number) {
        auto it = numbers[number % SIZE].find(number);
        return it != numbers[number % SIZE].end();
    }

    bool erase(long long number) {
        auto it = numbers[number % SIZE].find(number);
        if (it != numbers[number % SIZE].end()) {
            numbers[number % SIZE].erase(it);
            return true;
        }
        return false;
    }
};

struct OpenAddressing {
    vector<long long> numbers;
    vector<bool> vis;
    const size_t size = 1009, r = 4;
    const double A = 0.618033;
    int method, type;

    OpenAddressing(int method, int type) {
        numbers.resize(size, -1);
        vis.resize(size);
        this->method = method;
        this->type = type;
    }

    int linearProbing(int index, ll number) {
        int start = index;
        while (true) {
            if (numbers[index] == -1) {
                return index;
            }
            (index += 1) %= mod;
            if (index == start) return -1;
        }
    }

    int quadraticProbing(int index, ll number) {
        vector<int> passed;
        for (int i{};; ++i) {
            int curIndex = (index + i * i) % size;
            passed.emplace_back(curIndex);
            if (vis[curIndex]) break;
            vis[curIndex] = true;
            if (numbers[curIndex] == -1) {
                for (auto &idx: passed)
                    vis[idx] = false;
                return curIndex;
            }
        }
        for (auto &idx: passed)
            vis[idx] = false;
        return -1;
    }

    int getIndex(long long number) {
        if (method == 0) {
            return int(number % size);
        }
        if (method == 1) {
            return (int) floor(size * fmod(A * number, 1));
        }
        if (method == 2) {
            // assume no overflow
            ll squared_number = number * number;
            auto getIndex = [&]() {
                string s = to_string(squared_number);
                int num_of_digits = (int) s.size();
                if (num_of_digits <= 4) return squared_number;
                return stoll(s.substr((num_of_digits - 4) / 2, 4));
            };
            return (int) getIndex();
        }
        if (method == 3) {
            ll squared_number = number * number;
            auto getIndex = [&]() {
                string s = to_string(squared_number);
                int index{};
                for (size_t i{}; i < s.size(); i += r) {
                    if (i + r <= s.size()) {
                        index += stoi(s.substr(i, r));
                    } else {
                        index += stoi(s.substr(i));
                    }
                }
                return index % size;
            };
            return (int) getIndex();
        }
        return -1;
    };

    bool add(long long number) {
        int index = getIndex(number);
        if (index == -1) return false;
        if (type == 0) index = linearProbing(index, number);
        else index = quadraticProbing(index, number);
        if (index != -1) {
            numbers[index] = number;
            return true;
        }
        return false;
    }

    bool find(long long number) {
        int index = getIndex(number);
        if (index == -1) return false;
        if (type == 0) index = linearProbing(index, number);
        else index = quadraticProbing(index, number);
        if (index != -1) {
            return numbers[index] == number;
        }
        return false;
    }

    bool erase(long long number) {
        int index = getIndex(number);
        if (index == -1) return false;
        if (type == 0) index = linearProbing(index, number);
        else index = quadraticProbing(index, number);
        if (index != -1) {
            numbers[index] = -1;
            return true;
        }
        return false;
    }
};

struct doubleHash {
    vector<long long> numbers;
    vector<int> vis;
    const int SIZE = 1009, PRIME = 997;

    doubleHash() {
        numbers.resize(SIZE, -1);
        vis.resize(SIZE);
    }

    int Hash1(long long number) {
        return (int) number % SIZE;
    }

    int Hash2(long long number) {
        return int(PRIME - (number % PRIME));
    }

    int probe(int h1, int h2) {
        vector<int> passed;
        for (int i{};; ++i) {
            int curIndex = (h1 + i * h2) % SIZE;
            if (vis[curIndex])
                break;
            vis[curIndex] = true;
            passed.emplace_back(curIndex);
            if (numbers[curIndex] == -1) {
                for (auto &idx: passed) vis[idx] = false;
                return curIndex;
            }
        }
        for (auto &idx: passed)
            vis[idx] = false;
        return -1;
    }

    bool add(long long number) {
        int h1 = Hash1(number);
        int h2 = Hash2(number);
        int idx = probe(h1, h2);
        if (idx == -1) return false;
        numbers[idx] = number;
        return true;
    }

    bool find(long long number) {
        int h1 = Hash1(number);
        int h2 = Hash2(number);
        int idx = probe(h1, h2);
        if (idx == -1) return false;
        return numbers[idx] == number;
    }
    
    bool erase(long long number){
        int h1 = Hash1(number);
        int h2 = Hash2(number);
        int idx = probe(h1, h2);
        if (idx == -1) return false;
        numbers[idx] = -1;
        return true;
    }
};
